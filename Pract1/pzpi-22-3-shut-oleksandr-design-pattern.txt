Харківський національний університет радіоелектроніки
Факультет комп'ютерних наук
Катедра програмної інженерії
    
    
    
    
    
    
ЗВІТ
з практичного заняття №1
з дисципліни  «Архітектура програмного забезпечення»
на тему: «Патерни проєктування»
    
    
    
    
    
    
    Виконав
    ст. гр. ПЗПІ-22-3
    Шуть Олександр Вікторович

    Перевірив
    ст. викладач катедри ПІ
    Сокорчук Ігор Петрович
    


    
Харків 2025
ІСТОРІЯ ЗМІН
 
№	Дата	Версія звіту	Опис змін та виправлень
1	20.03.2025	0.1	Сформовано структуру звіту.
2	21.03.2025	0.1	Додано опис розділу «Завдання».
3	22.03.2025	0.1	Розглянуто принципи роботи патерну Абстрактна фабрика, його переваги, практичні приклади та недоліки.
4	22.03.2025	0.1	Заповнено додаток В, включено приклади коду, сформульовано висновки.
5	23.03.2025	0.1	Оновлено додаток Б, додано слайди презентації.
6	23.03.2025	0.1	Додано посилання на відеозапис доповіді із зазначенням часових міток. Виправлено зображення слайдів у додатку Б.

1 ЗАВДАННЯ

     Дослідити програмний патерн Абстрактна фабрика, його призначення, ключові риси, особливості реалізації та сфери застосування в об’єктноорієнтованому програмуванні. Розглянути структуру цього патерну, його роль у створенні груп взаємопов’язаних об’єктів та забезпеченні їхньої сумісності. Проаналізувати практичне використання Абстрактної фабрики та продемонструвати її принципи роботи на конкретних прикладах програмного коду, щоб наочно показати її ефективність у розробці програмного забезпечення.





2 ОПИС ВИКОНАНОЇ РОБОТИ
     
     Підготовлено доповідь, яка була представлена з супроводом у вигляді відеопрезентації. Посилання на відео можна знайти в додатку А, а слайди презентації наведено в додатку Б.
     У процесі розробки та оптимізації програмного забезпечення важливим аспектом є забезпечення гнучкості та масштабованості коду, що дозволяє адаптувати систему до змін у вимогах без необхідності переписування значної частини коду. Однією з основних проблем, що постають перед розробниками, є створення об'єктів, які повинні працювати разом, зберігаючи при цьому незалежність від конкретних реалізацій. Задля вирішення цієї проблеми широко використовуються патерни проєктування, серед яких патерн «Абстрактна фабрика» є одним із найбільш потужних інструментів для створення гнучких та підтримуваних програмних рішень.
     Патерн «Абстрактна фабрика» дозволяє створювати групи взаємопов’язаних об’єктів без прив’язки до конкретних класів, що є критично важливим для систем, які потребують високої гнучкості. Застосування цього патерну допомагає приховати деталі реалізації об'єктів від клієнтського коду, що забезпечує зручність в управлінні системою та її розширюваність. Це дозволяє змінювати набір об'єктів у програмі, не змінюючи основного коду, що значно спрощує підтримку програмного продукту.
     Крім того, патерн забезпечує дотримання принципу відкритості/закритості, що дозволяє додавати нові родини об'єктів без змін у вже існуючому коді. Такий підхід також полегшує тестування, оскільки завдяки абстракціям можна легко підміняти реалізації об'єктів для юніт-тестування. Однак застосування цього патерну також має свої недоліки, зокрема збільшення кількості класів, що може ускладнити архітектуру програми, а також потреба створення додаткових класів для кожної варіації продукту.
     Патерн «Абстрактна фабрика» особливо корисний у тих випадках, коли необхідно підтримувати кросплатформні додатки, створювати графічні інтерфейси з можливістю зміни теми або розробляти ігри та симуляції, де існує потреба в створенні об'єктів, що взаємодіють між собою. Водночас у простих системах або в системах, де не потрібно жорстке зв'язування між продуктами, використання цього патерну може бути надмірним і навіть призвести до зайвих ускладнень.
     Таким чином, вибір патерну «Абстрактна фабрика» залежить від конкретних потреб системи, складності та кількості варіацій продуктів, які необхідно підтримувати. У ситуаціях, коли система не передбачає значних змін або не потребує складної взаємодії між продуктами, цей патерн може бути зайвим, і в таких випадках доцільно застосовувати простіші підходи до створення об'єктів.
     
ВИСНОВКИ

     У результаті виконання даної практичної роботи було розглянуто шаблон Абстрактна фабрика. З’ясовано його переваги, зокрема забезпечення гнучкості, масштабованості та підтримки принципу відкритості/закритості. Описано недоліки, такі як ускладнення архітектури системи через необхідність створення великої кількості додаткових класів. Наведено приклади використання Абстрактної фабрики для створення сімейств взаємопов’язаних об’єктів у програмних системах.

ДОДАТОК А
Посилання на відеозапис доповіді

     Відеозапис доповіді на YouTube: https://youtu.be/LtmnP2ASjfI
     Нижче наведено хронологічний опис доповіді.
     00:00 Вітання. Оголошується ім’я доповідача та його академічна група.
     00:16 Зміст. Стислий перелік підтем, що будуть розглянуті протягом доповіді.
     00:38 Вступ. Описується контекст, у якому стає важливим застосування патерну Абстрактна фабрика.
     01:25 Проблеми, які вирішує Абстрактна фабрика 
     02:31 Визначення патерну Абстрактна фабрика 
     02:47 Основні риси патерну Абстрактна фабрика 
     03:57 Випадки застосування патерну Абстрактна фабрика 
     05:03 Приклад структури патерну. Частина 1 
     06:11 Приклад структури патерну. Частина 2 
     07:00 Приклад структури патерну. Частина 3 
     07:36 Переваги патерну Абстрактна фабрика 
     09:16 Недоліки патерну Абстрактна фабрика 
10:16 Коли не слід використовувати патерн Абстрактна фабрика
11:26 Висновки
ДОДАТОК Б
Слайди презентації доповіді


Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Зміст доповіді


Рисунок Б.3 – Вступ. Опис контексту важливості патерну Абстрактної фабрики


Рисунок Б.4 – Проблеми, які вирішує Абстрактна фабрика





Рисунок Б.5 – Визначення патерну Абстрактна фабрика


Рисунок Б.6 – Основні риси патерну Абстрактна фабрика


Рисунок Б.7 – Випадки застосування патерну Абстрактна фабрика


Рисунок Б.8 – Приклад структури патерну Абстрактна фабрика. Частина 1



Рисунок Б.9 – Приклад структури патерну Абстрактна фабрика. Частина 2


Рисунок Б.10 – Приклад структури патерну Абстрактна фабрика. Частина 3



Рисунок Б.11 – Переваги патерну Абстрактна фабрика


Рисунок Б.12 – Недоліки патерну Абстрактна фабрика



Рисунок Б.13 – Коли не слід використовувати патерн Абстрактна фабрика


Рисунок Б.14 – Висновки

ДОДАТОК В
Приклади програмного коду

     Приклад структури патерна  «Абстрактна фабрика».
     
01 /**
02  * Інтерфейс Абстрактної Фабрики оголошує набір методів, які повертають
03  * різні абстрактні продукти. Ці продукти називаються родиною і є
04  * взаємопов'язаними за допомогою загальної теми або концепції. Продукти однієї родини зазвичай
05  * можуть взаємодіяти між собою. Родина продуктів може мати кілька
06  * варіантів, але продукти одного варіанту несумісні з продуктами іншого.
07  */
08 interface AbstractFactory {
09   createProductA(): AbstractProductA;
10 
11   createProductB(): AbstractProductB;
12 }
13 
14 /**
15 * Конкретні фабрики створюють родину продуктів, що належать до одного
16 * варіанту. Фабрика гарантує, що створені продукти сумісні. Зверніть увагу,
17 * що підписи методів Конкретної Фабрики повертають абстрактний продукт,
18 * в той час як всередині методу створюється конкретний продукт.
19 */
20 class ConcreteFactory1 implements AbstractFactory {
21   public createProductA(): AbstractProductA {
22       return new ConcreteProductA1();
23   }
24
25   public createProductB(): AbstractProductB {
26       return new ConcreteProductB1();
27   }
28 }
29
30 /**
31 * Кожна Конкретна Фабрика має відповідний варіант продукту.
32 */
33 class ConcreteFactory2 implements AbstractFactory {
34   public createProductA(): AbstractProductA {
35       return new ConcreteProductA2();
36   }
37
38   public createProductB(): AbstractProductB {
39       return new ConcreteProductB2();
40   }
41 }
42
43 /**
44 * Кожен окремий продукт родини продуктів повинен мати базовий інтерфейс. Всі
45 * варіанти продукту повинні реалізовувати цей інтерфейс.
46 */
47 interface AbstractProductA {
48   usefulFunctionA(): string;
49 }
50
51 /**
52 * Ці Конкретні Продукти створюються відповідними Конкретними Фабриками.
53 */
54 class ConcreteProductA1 implements AbstractProductA {
55   public usefulFunctionA(): string {
56       return 'Результат продукту A1.';
57   }
58 }
59
60 class ConcreteProductA2 implements AbstractProductA {
61   public usefulFunctionA(): string {
62       return 'Результат продукту A2.';
63   }
64 }
65
66 /**
67 * Ось базовий інтерфейс для іншого продукту. Всі продукти можуть взаємодіяти
68 * один з одним, але правильна взаємодія можлива тільки між продуктами одного
69 * конкретного варіанту.
70 */
71 interface AbstractProductB {
72   /**
73    * Продукт B може виконувати свою функцію...
74    */
75   usefulFunctionB(): string;
76
77   /**
78    * ...але також може співпрацювати з Продуктом A.
79    *
80    * Абстрактна Фабрика гарантує, що всі продукти, які вона створює, належать
81    * до одного варіанту і, таким чином, сумісні.
82    */
83   anotherUsefulFunctionB(collaborator: AbstractProductA): string;
84 }
85
86 /**
87 * Ці Конкретні Продукти створюються відповідними Конкретними Фабриками.
88 */
89 class ConcreteProductB1 implements AbstractProductB {
90
91   public usefulFunctionB(): string {
92       return 'Результат продукту B1.';
93   }
94 
95   /**
96    * Варіант, Продукт B1, може коректно працювати тільки з варіантом
97    * Продукту A1. Проте, він приймає будь-який екземпляр AbstractProductA як
98    * аргумент.
99    */
100   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
101       const result = collaborator.usefulFunctionA();
102       return `Результат B1 у співпраці з (${result})`;
103   }
104 }
105
106 class ConcreteProductB2 implements AbstractProductB {
107
108   public usefulFunctionB(): string {
109       return 'Результат продукту B2.';
110   }
111
112   /**
113    * Варіант, Продукт B2, може коректно працювати тільки з варіантом
114    * Продукту A2. Проте, він приймає будь-який екземпляр AbstractProductA як
115    * аргумент.
116    */
117   public anotherUsefulFunctionB(collaborator: AbstractProductA): string {
118       const result = collaborator.usefulFunctionA();
119       return `Результат B2 у співпраці з (${result})`;
120   }
121 }
122
123 /**
124 * Клієнтський код працює з фабриками та продуктами тільки через абстрактні
125 * типи: AbstractFactory та AbstractProduct. Це дозволяє передавати будь-яку фабрику або
126 * підклас продукту в клієнтський код без порушення його роботи.
127 */
128 function clientCode(factory: AbstractFactory) {
129   const productA = factory.createProductA();
130   const productB = factory.createProductB();
131
132   console.log(productB.usefulFunctionB());
133   console.log(productB.anotherUsefulFunctionB(productA));
134 }
135
136 /**
137 * Клієнтський код може працювати з будь-яким класом конкретної фабрики.
138 */
139 console.log('Клієнт: Тестуємо клієнтський код з першим типом фабрики...');
140 clientCode(new ConcreteFactory1());
141
142 console.log('Клієнт: Тестуємо той самий клієнтський код з другим типом фабрики...');
143 clientCode(new ConcreteFactory2());